class UnionFind{
unordered_map<int,int> parent,size;

    public:
    UnionFind(int numberOfSets)
    {
        for(int set=0;set<=numberOfSets;set++)
            parent[set] = set,size[set]=1;
    }
    
    int findParent(int child)
    {
        if(child==parent[child])
            return child;
        return parent[child] = findParent(parent[child]);
    }
    
    void unionSet(int set1,int set2)
    {
        set1 = findParent(set1);
        set2 = findParent(set2);
        if(set1!=set2)
        {
            if(size[set1]<size[set2])
                swap(set1,set2);
            parent[set2] = set1;
            size[set1]+=size[set2];
        }
    }
    
    int getSize(int set)
    {
        return size[findParent(set)];
    }
};

class Solution {
public:
    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
        UnionFind unionFind(graph.size());
        
        for(int row=0;row<graph.size();row++)
        {
            for(int col=0;col<graph[0].size(); col++)
            {
                if(graph[row][col])
                    unionFind.unionSet(row,col);
            }
        }
        
        unordered_map<int,int> malwareCountInSets;
        
        sort(initial.begin(),initial.end());
        
        for(auto malware:initial)
            malwareCountInSets[unionFind.findParent(malware)]++;
        
        int maxSize = 0;
        int ans = -1;
        for(auto malware:initial)
        {
            int currentSetSize = unionFind.getSize(malware);
            if(currentSetSize>maxSize and malwareCountInSets[unionFind.findParent(malware)]==1)
            {
                maxSize = currentSetSize;
                ans = malware;
            }
        }
        
        return (ans==-1)?initial[0]:ans;
    }
};